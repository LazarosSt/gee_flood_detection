/*
***************************************************************************
  IMPORTS
***************************************************************************
*/


var S1_UTILITIES = require("users/stamlazaros/hua:t-h-e-s-i-s/utilities/s1");


/*
*********************************************************************
  FUNCTIONS
*********************************************************************
*/


//-----------------------Data Displaying Functions-----------------------

function create_legend_row(color, name) {
  /*
  Description:
    Creates and formats a single legend row. The row consists of
    two ui.Label objects, a color box and a description label.

  Parameters:
    color (string): A hex color code representing the color of the legend box.
    name  (string): A description for the legend entry.

  Returns:
    A ui.Panel object representing the legend row.
  */

  // Create the color box label.
  var colorBox = ui.Label({
    style: {
      backgroundColor: color,
      padding: "10px",
      margin: "4px"
    }
  });
 
  // Create the description label.
  var description = ui.Label({
    value: name,
    style: {
      margin: "5px",
    }
  });
 
  // Return the legend row panel.
  return ui.Panel({
    widgets: [colorBox, description],
    layout: ui.Panel.Layout.Flow("horizontal")
  });
}


function rectangular_grid(projection) {
  /*
  Description:
    Displays the pixel grid associated with a given projection as box outlines.
    Each pixel is represented by a rectangular box outline.

  Parameters:
    projection (ee.Projection): The projection to visualize the grid for.

  Returns:
    An ee.Image object representing the pixel grid.
  */

  // Scale by 2 because we have 2 zero crossings when using the round function.
  var cells = ee.Image.pixelCoordinates(projection.scale(2, 2));
  // Subtract rounded pixel coordinates from the original coordinates.
  var grid = cells.subtract(cells.round());
  // Identify the zero crossings to obtain the box outlines of the grid.
  var gridOutlines = grid.zeroCrossing();
  // Sum all the grid outlines to create a single image with the grid displayed.
  var gridImage = gridOutlines.reduce("sum");
  // Apply a self-mask to remove pixels outside the grid outlines.
  var maskedGrid = gridImage.selfMask();

  return maskedGrid;
}


/*
**********************************************************************
  PARAMETERS
**********************************************************************
*/


// `Dynamic World Land Cover`
var fromLabels = [1, 2, 3, 4, 5, 6, 7, 8];
var toLabels = [1, 1, 1, 1, 1, 1, 1, 1];

var dwStartDate = "2015-01-01";
var dwEndDate = "2016-01-01";

// `Digital Elevation`
var demProvider = "USGS";

// `Sentinel-1 GRD`
var b1 = "VV";
var b2 = "VH";

var preIdentifier = "003747_00476D_87B6";
var postIdentifier = "004447_005723_9D4B";

// Projections of interest.
var internalScale = 10;
var externalScale = 30;
var projectionCRS = "EPSG:4326";

// Sampling parameters.
var preCoverValue = 0;
var postCoverValue = 0;
var groupIdentifier = "emsr117";

var dict = {
  seed: 0,
  tileScale: 16,
  dropNulls: true,
  geometries: true,
  classBand: "class",
  numPoints: 10,
  classValues: [0],
  classPoints: [25000]
};

// GEE assets.
var rastersFolder = "users/stamlazaros/hua/t-h-e-s-i-s/assets/features/rasters/";
var vectorsFolder = "users/stamlazaros/hua/t-h-e-s-i-s/assets/features/vectors/";
var destinationPath = "users/stamlazaros/hua/t-h-e-s-i-s/assets/samples/non_water";

var DESIRED_REGIONS = [
  ee.FeatureCollection("FAO/GAUL/2015/level2")
];

var UNDESIRED_REGIONS = [
  ee.FeatureCollection("users/stamlazaros/hua/t-h-e-s-i-s/assets/filters/emsr117/flood_surfaces"),
  ee.FeatureCollection("users/stamlazaros/hua/t-h-e-s-i-s/assets/filters/emsr117/water_surfaces"),
  ee.FeatureCollection("users/stamlazaros/hua/t-h-e-s-i-s/case_studies/emsr692/vectors/magnesia/area_of_interest")
];


/*
********************************************************************
  CONFIGURATION
********************************************************************
*/


// `Digital Elevation Models`
var demConfigs = {
  CGIAR: {    // `SRTM Digital Elevation Data Version 4`
    name: "CGIAR/SRTM90_V4"
  },
  USGS: {     // `NASA SRTM Digital Elevation`
    name: "USGS/SRTMGL1_003"
  },
  NASA: {     // `NASA NASADEM Digital Elevation`
    name: "NASA/NASADEM_HGT/001"
  },
  ASTER: {    // `AG100: ASTER Global Emissivity Dataset 100-meter V003`
    name: "NASA/ASTER_GED/AG100_003"
  }
};

// `Sentinel-1 GRD`
var sarBluishVisualization = {
  min:[-18, -25, 1],
  max:[0, -5, 12],
  bands: ["VV", "VH", "VVVHD"]
};

var sarReddishVisualization = {
  min: [-25, -25, 0],
  max: [0, 0, 2],
  bands: ["VV", "VH", "VVVHQ"]
};

// `Dynamic World LULC v1`
var dwConfig = {
  name: "GOOGLE/DYNAMICWORLD/V1"
};

var emptyLabels = ee.Dictionary({
  "0": 0,
  "1": 0,
  "2": 0,
  "3": 0,
  "4": 0,
  "5": 0,
  "6": 0,
  "7": 0,
  "8": 0
});

var dwLabelsPalette = {
  "water": "419BDF",
  "trees": "397D49",
  "grass": "88B053",
  "flooded vegetation": "7A87C6",
  "crops": "E49635",
  "shrub & scrub": "DFC35A",
  "built": "C4281B",
  "bare": "A59B8F",
  "snow & ice": "B39FE1"
};

var dwLabels = Object.keys(dwLabelsPalette);

var dwPalette = dwLabels.map(function(key){
  return dwLabelsPalette[key];
});

var dwVisualization = {
  min: 0,
  max: 8,
  bands: ["dw"],
  palette: dwPalette
};

// OTSU algorithm
var coverVisualization = {
  min: 0,
  max: 1,
  bands: ["OTSU"],
  palette: ["deb887", "45b6fe"]
};

// GEE assets.
var footprints = {
  pre_event: vectorsFolder + preIdentifier,
  post_event: vectorsFolder + postIdentifier
};

var features = {
  pre_event: rastersFolder + preIdentifier,
  post_event: rastersFolder + postIdentifier
};

var demConfig = demConfigs[demProvider];


/*
****************************************************************
  COMPUTATIONS
****************************************************************
*/


// Define the projections of interest.

var internalProjection = ee.Projection(projectionCRS).atScale(internalScale);
var externalProjection = ee.Projection(projectionCRS).atScale(externalScale);

// Handle the geometries.

var preEventFootprint = ee.FeatureCollection(footprints.pre_event).geometry();
var postEventFootprint = ee.FeatureCollection(footprints.post_event).geometry();
var footprint = preEventFootprint.intersection(postEventFootprint).buffer(-10000);

dict.region = footprint;

DESIRED_REGIONS = ee.FeatureCollection(DESIRED_REGIONS).flatten();
UNDESIRED_REGIONS = ee.FeatureCollection(UNDESIRED_REGIONS).flatten();

var desiredRegions = ee.Image.constant(1)
  .clipToCollection(DESIRED_REGIONS)
  .clip(footprint)
  .int();

var undesiredRegions = ee.Image.constant(0)
  .clipToCollection(UNDESIRED_REGIONS)
  .clip(footprint)
  .int();

var regionsMosaic = ee.ImageCollection([desiredRegions, undesiredRegions])
  .mosaic()
  .selfMask()
  .reproject(internalProjection);

// Load, filter and process the rasters.

// `Digital Elevation`
var elevation = ee.Image(demConfig.name).unmask().clip(footprint);
var slope = ee.Terrain.slope(elevation);

// `Dynamic World Land Cover V1`
var dwCollection = ee.ImageCollection(dwConfig.name)
  .filterDate(dwStartDate, dwEndDate)
  .filterBounds(footprint);

// Create a LULC mask.
var dwMosaic = dwCollection
  .mode()
  .select("label")
  .rename("dw")
  .clip(footprint)
  .reproject(internalProjection);

var dwCover = dwMosaic.remap({
    from: fromLabels,
    to: toLabels,
    bandName: "dw"
  })
  .rename("DW_COVER")
  .selfMask();

// `Sentinel-1 GRD`
var preEventRaster = ee.Image(features.pre_event);
var postEventRaster = ee.Image(features.post_event);

var classMask = ee.ImageCollection([preEventRaster, postEventRaster])
  .select("OTSU").reduce(ee.Reducer.sum()).rename("class");

var otsuMask = preEventRaster.select("OTSU").eq(preCoverValue)
  .bitwiseAnd(postEventRaster.select("OTSU").eq(postCoverValue))
  .rename("OTSU").selfMask();

// Engineer new bands.

var differenceExpression = S1_UTILITIES.bandCombinations.difference.expression;
var quotientExpression = S1_UTILITIES.bandCombinations.quotient.expression;
var ndpiExpression = S1_UTILITIES.bandCombinations.ndpi.expression;

var differenceName = S1_UTILITIES.bandCombinations.difference.name;
var quotientName = S1_UTILITIES.bandCombinations.quotient.name;
var ndpiName = S1_UTILITIES.bandCombinations.ndpi.name;

// `PRE_VVVHD`
var prevvprevhDifference = ee.Image().expression({
    expression: differenceExpression,
    map: {
      b1: preEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  }).rename(differenceName.replace("b1", b1).replace("b2", b2));

// `POST_VVVHD`
var postvvpostvhDifference = ee.Image().expression({
    expression: differenceExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: postEventRaster.select(b2)
    }
  }).rename(differenceName.replace("b1", b1).replace("b2", b2));

// `VVVVD`
var postvvprevvDifference = ee.Image().expression({
    expression: differenceExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: preEventRaster.select(b1)
    }
  })
  .rename(differenceName.replace("b1", b1).replace("b2", b1));

// `VHVHD`
var postvhprevhDifference = ee.Image().expression({
    expression: differenceExpression,
    map: {
      b1: postEventRaster.select(b2),
      b2: preEventRaster.select(b2)
    }
  })
  .rename(differenceName.replace("b1", b2).replace("b2", b2));

// `VVVHD`
var postvvprevhDifference = ee.Image().expression({
    expression: differenceExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  })
  .rename(differenceName.replace("b1", b1).replace("b2", b2));

// `PRE_VVVHQ`
var prevvprevhQuotient = ee.Image().expression({
    expression: quotientExpression,
    map: {
      b1: preEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// `POST_VVVHQ`
var postvvpostvhQuotient = ee.Image().expression({
    expression: quotientExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: postEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// `VVVVQ`
var postvvprevvQuotient = ee.Image().expression({
    expression: quotientExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: preEventRaster.select(b1)
    }
  })
  .rename(quotientName.replace("b1", b1).replace("b2", b1));

// `VHVHQ`
var postvhprevhQuotient = ee.Image().expression({
    expression: quotientExpression,
    map: {
      b1: postEventRaster.select(b2),
      b2: preEventRaster.select(b2)
    }
  })
  .rename(quotientName.replace("b1", b2).replace("b2", b2));

// `VVVHQ`
var postvvprevhQuotient = ee.Image().expression({
    expression: quotientExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  })
  .rename(quotientName.replace("b1", b1).replace("b2", b2));

// `PRE_NDPI`
var preNDPI = ee.Image().expression({
    expression: ndpiExpression,
    map: {
      b1: preEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  }).rename("PRE_NDPI");

// `POST_NDPI`
var postNDPI = ee.Image().expression({
    expression: ndpiExpression,
    map: {
      b1: postEventRaster.select(b1),
      b2: postEventRaster.select(b2)
    }
  }).rename("POST_NDPI");

// `NDPID`
var NDPID = postNDPI.subtract(preNDPI).rename("NDPID");

// Rename S1-GRD raster bands using a regular expression.
var preEventSamplesSource = preEventRaster.regexpRename("^", "PRE_", false);
var postEventSamplesSource = postEventRaster.regexpRename("^", "POST_", false);

// Add bands to both pre- & post- event rasters.
preEventRaster = preEventRaster.addBands([prevvprevhDifference, prevvprevhQuotient]);
postEventRaster = postEventRaster.addBands([postvvpostvhDifference, postvvpostvhQuotient]);

// Generate a collection of random samples.

// Construct the pixel grid as box outlines.
var rectangularGrid = rectangular_grid(externalProjection).clip(footprint);

// Create an even pixel coordinates mask (in either X or Y).
var outerMask = ee.Image.pixelCoordinates(externalProjection)
  .expression("!((b('x') + 0.5) % 2 != 0 || (b('y') + 0.5) % 2 != 0)");

// Create a cells mask.
var cells = ee.Image.random()
  .rename("ID")
  .clip(footprint)
  .multiply(1000000)
  .int()
  .reproject(externalProjection);

// Retain only relevant cells.
cells = cells.updateMask(cells.mask().gt(0)).updateMask(outerMask).reproject(externalProjection);

// Extract stratified random samples.
var samplesSource = cells.addBands([
    preEventSamplesSource, postEventSamplesSource, postvvprevvDifference,
    postvhprevhDifference, postvvprevhDifference, postvvprevvQuotient,
    postvhprevhQuotient, postvvprevhQuotient, preNDPI, postNDPI,
    NDPID, dwMosaic, dwCover, otsuMask, classMask, slope, regionsMosaic
  ]);

var samples = samplesSource.stratifiedSample(dict);

samples = samples.map(function(sample){
  sample = sample.set("group", groupIdentifier);
  return sample;
});

// Generate charts.

// DW label frequencies.
var multiplicities = samples
  .aggregate_histogram("dw")
  .combine(emptyLabels, false);

var samplesChart = ui.Chart.array.values({
    array: multiplicities.values(),
    axis: 0,
    xLabels: dwLabels
  })
  .setOptions({
    title: "DW Label Frequencies",
    colors: dwPalette,
    pieHole: 0.2
  })
  .setChartType("PieChart");


/*
***************************************************************
  CONSOLE
***************************************************************
*/


print(samplesChart);

print("*samples*");
print("number of samples:", samples.size());
print("indicative sample: ", samples.first());

print("*rasters*");
print("samples-source features:", samplesSource.bandNames());


/*
**************************************************************
  VISUALIZATION
**************************************************************
*/


// Generate categorical legends.

// `Dynamic-World`
var dwLegend = ui.Panel({
  style: {
    position: "bottom-left",
    padding: "5px"
  }
});

var dwLegendTitle = ui.Label({
  value: "DW",
  style: {margin: "0px", fontSize: "14px", fontWeight: "bold"}
});

dwLegend.add(dwLegendTitle);

for (var key in dwLabelsPalette) {
  dwLegend.add(create_legend_row(dwLabelsPalette[key], key));
}

Map.add(dwLegend);
Map.centerObject(footprint);

Map.addLayer(preEventRaster, sarReddishVisualization, "rasters: S1-GRD (pre)");
Map.addLayer(preEventRaster, coverVisualization, "rasters: binary mask (pre)");

Map.addLayer(postEventRaster, sarReddishVisualization, "rasters: S1-GRD (post)");
Map.addLayer(postEventRaster, coverVisualization, "rasters: binary mask (post)");

Map.addLayer(dwMosaic, dwVisualization, "rasters: DW");

Map.addLayer(rectangularGrid, {palette: ["DAA520"]}, "rasters: grid");
Map.addLayer(cells.randomVisualizer(), {}, "rasters: cells");
Map.addLayer(footprint, {color: "white"}, "vectors: footprint");
Map.addLayer(samples, {}, "vectors: samples");


/*
**************************************************************
  EXPORT
**************************************************************
*/


samples = samples.select([
  "group", "class", "dw", "NDPID", "POST_NDPI", "POST_VH", "POST_VV", "PRE_NDPI",
  "PRE_VH", "PRE_VV", "VHVHD",  "VHVHQ", "VVVHD", "VVVHQ", "VVVVD", "VVVVQ"
]);

var samplesIdentifier = [preIdentifier, postIdentifier].join("_");

Export.table.toAsset({
  collection: samples,
  assetId: [destinationPath, samplesIdentifier].join("/"),
  description: [samplesIdentifier, "to_asset"].join("_"),
});

samples = samples.map(function(sample){
  var coordinates = sample.geometry().coordinates();
  sample = sample.set("longitude", coordinates.get(0));
  sample = sample.set("latitude", coordinates.get(1));

  return sample;
});

Export.table.toDrive({
  collection: samples,
  folder: "samples",
  fileNamePrefix: samplesIdentifier,
  description: [samplesIdentifier, "to_gd"].join("_"),
  fileFormat: "CSV",
  selectors: [
    "group", "longitude", "latitude", "class", "dw", "NDPID","POST_NDPI",
    "POST_VH", "POST_VV",  "PRE_NDPI", "PRE_VH", "PRE_VV", "VHVHD",
    "VHVHQ",  "VVVHD", "VVVHQ", "VVVVD", "VVVVQ",
  ]
});
