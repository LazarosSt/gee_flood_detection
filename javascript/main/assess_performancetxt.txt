/*
**********************************************************************
  IMPORTS
**********************************************************************
*/


var CASE_STUDIES = require("users/stamlazaros/hua:t-h-e-s-i-s/configurations/case_studies");


/*
**********************************************************************
  PARAMETERS
**********************************************************************
*/


// Projection of interest.
var projectionCRS = "EPSG:4326";
var projectionScale = 10;

// EMS case of interest.
var caseCode = "emsr692";
var caseArea = "magnesia";

// `Classification`
var rasterIdentifier = "041299_04E8BD_E9C5_050224_060B99_D80F";
var preEventRasterIdentifier = "S1A_IW_GRDH_1SDV_20220103T162359_20220103T162424_041299_04E8BD_E9C5";
var postEventRasterIdentifier = "S1A_IW_GRDH_1SDV_20230907T162412_20230907T162437_050224_060B99_D80F";

var groundTruth = ee.Image("users/stamlazaros/hua/t-h-e-s-i-s/case_studies/emsr692/rasters/magnesia/2023_09_07/ground_truth");
var classification = ee.Image("users/stamlazaros/hua/t-h-e-s-i-s/case_studies/emsr692/rasters/classified/2023_09_07/041299_04E8BD_E9C5_050224_060B99_D80F_base");

var classifierIdentifier = "base";
var classifierPath = "users/stamlazaros/hua/t-h-e-s-i-s/assets/classifiers/base";


/*
********************************************************************
  CONFIGURATION
********************************************************************
*/


// GEE assets
var caseConfig = CASE_STUDIES.cases[caseCode][caseArea];
var regionVectors = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");

var areaOfInterest = caseConfig.area_of_interest.geometry();
var ring = ee.Geometry.LinearRing(areaOfInterest.coordinates().flatten());

// `Classification`
var classVisualization = {
  min: 0,
  max: 2,
  palette: ["deb887", "C60404", "45b6fe"]
};


/*
****************************************************************
  COMPUTATIONS
****************************************************************
*/


// Define the projection of interest.
var projection = ee.Projection(projectionCRS).atScale(projectionScale);

// Retrieve classifier features.
var classifierFeatures = ee.FeatureCollection(classifierPath).get("features");

// Load, filter and process the raster collections.

// Exclude sea water surfaces.
var regionsRaster = regionVectors.filterBounds(caseConfig.area_of_interest)
  .map(function(line){
    return line.set("cover", 1);
  })
  .reduceToImage({
  properties: ["cover"],
  reducer: ee.Reducer.first()
})
.clipToCollection(caseConfig.area_of_interest)
.reproject(projection);

classification = classification.updateMask(regionsRaster);
groundTruth = groundTruth.updateMask(regionsRaster);

// Visualize classification outlines.

// Create an empty image for rendering.
var emptyImage = ee.Image().byte();

// Water surfaces
var waterClassificationExtent = classification
  .updateMask(classification.eq(2))
  .reduceToVectors({
    geometry: caseConfig.area_of_interest.geometry(),
    crs: projectionCRS,
    scale: projectionScale,
    geometryType: "polygon",
    maxPixels: 1e13,
    tileScale: 16,
    reducer: null
  });

waterClassificationExtent = ee.FeatureCollection(waterClassificationExtent);

var waterClassificationOutline = emptyImage.paint({
  featureCollection: waterClassificationExtent,
  color: 1,
  width: 2
});

// Flood surfaces.
var floodClassificationExtent = classification
  .updateMask(classification.eq(1))
  .reduceToVectors({
    geometry: caseConfig.area_of_interest.geometry(),
    crs: projectionCRS,
    scale: projectionScale,
    geometryType: "polygon",
    maxPixels: 1e13,
    tileScale: 16,
    reducer: null
  });

floodClassificationExtent = ee.FeatureCollection(floodClassificationExtent);

var floodClassificationOutline = emptyImage.paint({
  featureCollection: floodClassificationExtent,
  color: 1,
  width: 2
});

// Compute performance metrics.

var composite = groundTruth.addBands(classification);

var pixels = composite.sample({
  region: caseConfig.area_of_interest.geometry(),
  numPixels: 1e7,
  scale: projectionScale,
  projection: projectionCRS
});

var errorMatrix = pixels.errorMatrix("class", "classification", [0, 1, 2]);

errorMatrix.evaluate(function(matrix){

  var TP0 = matrix[0][0];
  var TN0 = matrix[1][1] + matrix[1][2] + matrix[2][1] + matrix[2][2];
  var FP0 = matrix[0][1] + matrix[0][2];
  var FN0 = matrix[1][0] + matrix[2][0];
  var rowTotal0 = matrix[0][0] + matrix[0][1] + matrix[0][2];
  var columnTotal0 = matrix[0][0] + matrix[1][0] + matrix[2][0];

  var TP1 = matrix[1][1];
  var TN1 = matrix[0][0] + matrix[0][2] + matrix[2][0] + matrix[2][2];
  var FP1 = matrix[1][0] + matrix[1][2];
  var FN1 = matrix[0][1] + matrix[2][1];
  var rowTotal1 = matrix[1][0] + matrix[1][1] + matrix[1][2];
  var columnTotal1 = matrix[0][1] + matrix[1][1] + matrix[2][1];

  var TP2 = matrix[2][2];
  var TN2 = matrix[0][0] + matrix[0][1] + matrix[1][0] + matrix[1][1];
  var FP2 = matrix[2][0] + matrix[2][1];
  var FN2 = matrix[0][2] + matrix[1][2];
  var rowTotal2 = matrix[2][0] + matrix[2][1] + matrix[2][2];
  var columnTotal2 = matrix[0][2] + matrix[1][2] + matrix[2][2];

  var overallAccuracy = (TP0 + TP1 + TP2) / (rowTotal0 + rowTotal1 + rowTotal2);

  var recall0 = TP0 / (TP0 + FN0);
  var recall1 = TP1 / (TP1 + FN1);
  var recall2 = TP2 / (TP2 + FN2);

  var precision0 = TP0 / (TP0 + FP0);
  var precision1 = TP1 / (TP1 + FP1);
  var precision2 = TP2 / (TP2 + FP2);

  var f1Score0 = (2 * precision0 * recall0) / (precision0 + recall0);
  var f1Score1 = (2 * precision1 * recall1) / (precision1 + recall1);
  var f1Score2 = (2 * precision2 * recall2) / (precision2 + recall2);

  var accuracy0 = (TP0 + TN0) / (TP0 + FP0 + FN0 + TN0);
  var accuracy1 = (TP1 + TN1) / (TP1 + FP1 + FN1 + TN1);
  var accuracy2 = (TP2 + TN2) / (TP2 + FP2 + FN2 + TN2);

  var producerAccuracy0 = TP0 / rowTotal0;
  var producerAccuracy1 = TP1 / rowTotal1;
  var producerAccuracy2 = TP2 / rowTotal2;

  var userAccuracy0 = TP0 / columnTotal0;
  var userAccuracy1 = TP1 / columnTotal1;
  var userAccuracy2 = TP2 / columnTotal2;

  var jaccard0 = TP0 / (TP0 + FP0 + FN0);
  var jaccard1 = TP1 / (TP1 + FP1 + FN1);
  var jaccard2 = TP2 / (TP2 + FP2 + FN2);

  var performanceMetrics = ee.Feature(ee.Geometry.Point([0,0]))
    .set("classifier_identifier", classifierIdentifier)
    .set("classifier_features", classifierFeatures)
    .set("raster_pre_event", preEventRasterIdentifier)
    .set("raster_post_event", postEventRasterIdentifier)
    .set("code", caseCode)
    .set("area", caseArea)
    .set("actual_class_0", matrix[0].toString())
    .set("actual_class_1", matrix[1].toString())
    .set("actual_class_2", matrix[2].toString())
    .set("class_0_accuracy", accuracy0)
    .set("class_0_recall", recall0)
    .set("class_0_precision", precision0)
    .set("class_0_f1_score", f1Score0)
    .set("class_0_jaccard", jaccard0)
    .set("class_0_user_accuracy", userAccuracy0)
    .set("class_0_producer_accuracy", producerAccuracy0)
    .set("class_1_accuracy", accuracy1)
    .set("class_1_recall", recall1)
    .set("class_1_precision", precision1)
    .set("class_1_f1_score", f1Score1)
    .set("class_1_jaccard", jaccard1)
    .set("class_1_user_accuracy", userAccuracy1)
    .set("class_1_producer_accuracy", producerAccuracy1)
    .set("class_2_accuracy", accuracy2)
    .set("class_2_recall", recall2)
    .set("class_2_precision", precision2)
    .set("class_2_f1_score", f1Score2)
    .set("class_2_jaccard", jaccard2)
    .set("class_2_user_accuracy", userAccuracy2)
    .set("class_2_producer_accuracy", producerAccuracy2);


  /*
  **************************************************************
    CONSOLE
  **************************************************************
  */


  print("Total number of pixels:", pixels.size());
  print("Confusion-Matrix:", errorMatrix);

  print("Class 0:");
  print("\tAccuracy:            " + accuracy0);
  print("\tRecall:              " + recall0);
  print("\tPrecision:           " + precision0);
  print("\tF1-score:            " + f1Score0);
  print("\tJaccard index:       " + jaccard0);
  print("\tUser's accuracy:     " + userAccuracy0);
  print("\tProducer's accuracy: " + producerAccuracy0);

  print("Class 1:");
  print("\tAccuracy:            " + accuracy1);
  print("\tRecall:              " + recall1);
  print("\tPrecision:           " + precision1);
  print("\tF1-score:            " + f1Score1);
  print("\tJaccard index:       " + jaccard1);
  print("\tUser's accuracy:     " + userAccuracy1);
  print("\tProducer's accuracy: " + producerAccuracy1);

  print("Class 2:");
  print("\tAccuracy:            " + accuracy2);
  print("\tRecall:              " + recall2);
  print("\tPrecision:           " + precision2);
  print("\tF1-score:            " + f1Score2);
  print("\tJaccard index:       " + jaccard2);
  print("\tUser's accuracy:     " + userAccuracy2);
  print("\tProducer's accuracy: " + producerAccuracy2);
});


/*
**************************************************************
  VISUALIZATION
**************************************************************
*/


Map.centerObject(caseConfig.area_of_interest);

Map.addLayer(classification, classVisualization, "rasters: classification");
Map.addLayer(groundTruth, classVisualization, "rasters: ground-truth");

Map.addLayer(groundTruth.eq(0).selfMask(), {palette: ["deb887"]}, "rasters: ground truth (non-water)");
Map.addLayer(groundTruth.eq(2).selfMask(), {palette: ["45b6fe"]}, "rasters: ground truth (water)");
Map.addLayer(groundTruth.eq(1).selfMask(), {palette: ["C60404"]}, "rasters: ground truth (flood)");

Map.addLayer(waterClassificationOutline, {palette: "purple"}, "vectors: classified outline (water)");
Map.addLayer(floodClassificationOutline, {palette: "green"}, "vectors: classified outline (flood)");

Map.addLayer(ring, {color: "white"}, "vectors: area of interest");
