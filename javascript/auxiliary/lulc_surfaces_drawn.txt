/*
***************************************************************************
  IMPORTS
***************************************************************************
*/


var CASE_STUDIES = require("users/stamlazaros/hua:t-h-e-s-i-s/configurations/case_studies");
var S1_UTILITIES = require("users/stamlazaros/hua:t-h-e-s-i-s/utilities/s1");
var S2_UTILITIES = require("users/stamlazaros/hua:t-h-e-s-i-s/utilities/s2");


/*
*********************************************************************
  FUNCTIONS
*********************************************************************
*/


//-----------------------Data Displaying Functions-----------------------

function add_drawing_layer(geometries, name){
  /*
  Description:
    Adds a drawing layer to the map using specified geometries and a name.

  Parameters:
    geometries (string): The geometry of the featureCollection to add as a drawing layer.
    name  (string): The name for the drawing layer.

  Returns:
    -

  Execution:
    var polygons = ee.FeatureCollection("...")
    polygons.geometry().evaluate(function(geometries){
      add_drawing_layer(geometries, "kati");
    });
  */
  Map.drawingTools().addLayer([geometries], name);
}

function create_legend_row(color, name) {
  /*
  Description:
    Creates and formats a single legend row. The row consists of
    two ui.Label objects, a color box and a description label.

  Parameters:
    color (string): A hex color code representing the color of the legend box.
    name  (string): A description for the legend entry.

  Returns:
    A ui.Panel object representing the legend row.
  */

  // Create the color box label.
  var colorBox = ui.Label({
    style: {
      backgroundColor: color,
      padding: "10px",
      margin: "4px"
    }
  });
 
  // Create the description label.
  var description = ui.Label({
    value: name,
    style: {
      margin: "5px",
    }
  });
 
  // Return the legend row panel.
  return ui.Panel({
    widgets: [colorBox, description],
    layout: ui.Panel.Layout.Flow("horizontal")
  });
}


/*
**********************************************************************
  PARAMETERS
**********************************************************************
*/


// `Harmonized Sentinel-2 MSI Level-2A`
var s2StartDate = "2023-09-01";
var s2EndDate = "2023-10-01";

var cloudProbability = 65;

// `Dynamic World Land Cover`
var dwStartDate = "2023-01-01";
var dwEndDate = "2023-09-01";

// `Digital Elevation Model`
var demProvider = "USGS";

// `Sentinel-1 GRD`
var b1 = "VV";
var b2 = "VH";

var rasterIdentifiers = {
  pre_event: "S1A_IW_GRDH_1SDV_20220103T162424_20220103T162449_041299_04E8BD_ABDB",
  post_event: "S1A_IW_GRDH_1SDV_20230907T162437_20230907T162502_050224_060B99_3635"
};

// OTSU algorithm
var vvkwargDefaults = {
  "initialThreshold":-15,
  "reductionScale": 180,
  "smoothing": 100,
  "bandName": "VV",
  "connectedPixels": 100,
  "edgeLength": 35,
  "smoothEdges": 20,
  "cannyThreshold": 0.5,
  "cannySigma": 1,
  "cannyLt": 0.8,
  "maxBuckets": 256,
  "minBucketWidth": 0.001,
  "maxRaw": 1e6
};

var vhkwargDefaults = {
  "initialThreshold":-15,
  "reductionScale": 180,
  "smoothing": 100,
  "bandName": "VH",
  "connectedPixels": 100,
  "edgeLength": 35,
  "smoothEdges": 20,
  "cannyThreshold": 0.5,
  "cannySigma": 1,
  "cannyLt": 0.8,
  "maxBuckets": 256,
  "minBucketWidth": 0.001,
  "maxRaw": 1e6
};

var polyCoordinates = [
  22.323465546605185, 39.896991761124596,
  22.938699921605185, 39.896991761124596,
  22.938699921605185, 40.35900075939832,
  22.323465546605185, 40.35900075939832,
];

// Runtime stuff.
var drawnGeometries = rivers;

// Projection of interest.
var projectionCRS = "EPSG:4326";
var projectionScale = 10;

// GEE assets.
var destinationPath = "users/stamlazaros/t-h-e-s-i-s/assets/filters/emsr117/flood_surfaces";


/*
********************************************************************
                            CONFIGURATION
********************************************************************
*/


// `Digital Elevation Models`
var demConfigs = {
  CGIAR: {    // `SRTM Digital Elevation Data Version 4`
    name: "CGIAR/SRTM90_V4"
  },
  USGS: {     // `NASA SRTM Digital Elevation`
    name: "USGS/SRTMGL1_003"
  },
  NASA: {     // `NASA NASADEM Digital Elevation`
    name: "NASA/NASADEM_HGT/001"
  },
  ASTER: {    // `AG100: ASTER Global Emissivity Dataset 100-meter V003`
    name: "NASA/ASTER_GED/AG100_003"
  }
};

// `Sentinel-1 GRD`
var s1Config = {
  name: "COPERNICUS/S1_GRD"
};

var s1Visualization = {
  min: [-25, -25, 0],
  max: [0, 0, 2],
  bands: ["VV", "VH", "VVVHQ"]
};

// `Dynamic World LULC v1`
var dwConfig = {
  name: "GOOGLE/DYNAMICWORLD/V1"
};

var dwLabelsPalette = {
  "water": "419BDF",
  "trees": "397D49",
  "grass": "88B053",
  "flooded vegetation": "7A87C6",
  "crops": "E49635",
  "shrub & scrub": "DFC35A",
  "built": "C4281B",
  "bare": "A59B8F",
  "snow & ice": "B39FE1"
};

var dwLabels = Object.keys(dwLabelsPalette);

var dwPalette = dwLabels.map(function(key){
  return dwLabelsPalette[key];
});

var dwVisualization = {
  min: 0,
  max: 8,
  bands: ["label"],
  palette: dwPalette
};

// `Harmonized Sentinel-2 MSI Level-2A`
var sen2HarmonizedConfig = {
  name: "COPERNICUS/S2_SR_HARMONIZED"
};

var sen2CloudsConfig = {
  name: "COPERNICUS/S2_CLOUD_PROBABILITY"
};

var rgbVisualization = {
  min: 0,
  max: 3000,
  bands: ["B4", "B3", "B2"]
};

var mndwiVisualization = {
  min: -1,
  max: 0.5,
  bands: ["MNDWI"],
  palette: ["red", "yellow", "green", "blue"]
};

// Visualizations
var coverVisualization = {
  min: 0,
  max: 1,
  palette: ["deb887", "45b6fe"]
};

// GEE assets.
var demConfig = demConfigs[demProvider];
var regionVectors = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");


/*
****************************************************************
  COMPUTATIONS
****************************************************************
*/


// Define the projection of interest.

var projection = ee.Projection(projectionCRS).atScale(projectionScale);

// Load, filter and process the raster collections.

// `Digital Elevation`
var elevation = ee.Image(demConfig.name).unmask();

// `Sentinel-1 GRD`
var preEventRaster = ee.Image([s1Config.name, rasterIdentifiers.pre_event].join("/"));
var postEventRaster = ee.Image([s1Config.name, rasterIdentifiers.post_event].join("/"));

preEventRaster = preEventRaster.addBands({
  srcImg: preEventRaster.select("angle").updateMask(preEventRaster.select("angle").mask().gt(0)),
  overwrite: true,
});

postEventRaster = postEventRaster.addBands({
  srcImg: postEventRaster.select("angle").updateMask(postEventRaster.select("angle").mask().gt(0)),
  overwrite: true,
});

// Handle geometries.
var preEventFootprint = preEventRaster.geometry();
var postEventFootprint = postEventRaster.geometry();

var footprint = preEventFootprint.intersection(postEventFootprint, 1);
var ring = ee.Geometry.LinearRing(footprint.coordinates().flatten());

// Apply angular-based radiometric slope correction.
var preEventRaster = S1_UTILITIES.slope_correction(preEventRaster, elevation);
var postEventRaster = S1_UTILITIES.slope_correction(postEventRaster, elevation);

// Apply a Refined-Lee speckle filter to reduce noise.
preEventRaster = S1_UTILITIES.refined_lee(preEventRaster);
postEventRaster = S1_UTILITIES.refined_lee(postEventRaster);

preEventRaster = ee.Image(preEventRaster);
postEventRaster = ee.Image(postEventRaster);

// Engineer new bands.

var quotientName = S1_UTILITIES.bandCombinations.quotient.name;

// `PRE_VVVHQ`
var prevvprevhQuotient = ee.Image().expression({
    expression: S1_UTILITIES.bandCombinations.quotient.expression,
    map: {
      b1: preEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// `POST_VVVHQ`
var postvvpostvhQuotient = ee.Image().expression({
    expression: S1_UTILITIES.bandCombinations.quotient.expression,
    map: {
      b1: postEventRaster.select(b1),
      b2: postEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// Incorporate extra bands into both pre- & post- event rasters.
preEventRaster = preEventRaster.addBands([prevvprevhQuotient]);
postEventRaster = postEventRaster.addBands([postvvpostvhQuotient]);

// `Dynamic World Land Cover V1`
var dwCollection = ee.ImageCollection(dwConfig.name)
  .filterDate(dwStartDate, dwEndDate)
  .filterBounds(footprint);

// Generate a mosaic.
var dwMosaic = dwCollection
  .mode()
  .select(["label"])
  .clip(footprint);

// `Harmonized Sentinel-2 MSI Level-2A`
var s2Collection = ee.ImageCollection(sen2HarmonizedConfig.name)
  .filterDate(s2StartDate, s2EndDate)
  .filterBounds(footprint);

// Aggregate the system index values.
var s2Indexes = s2Collection.aggregate_array("system:index");

// `Sentinel-2: Cloud Probability`
var s2Clouds = ee.ImageCollection(sen2CloudsConfig.name)
  .filter(ee.Filter.inList("system:index", s2Indexes));

// Join the two collecctions based on the system index values.
var mergedS2Collection = ee.Join.saveFirst("cloud_mask").apply({
  primary: s2Collection,
  secondary: s2Clouds,
  condition:
    ee.Filter.equals({leftField: "system:index", rightField: "system:index"})
});

// Perform cloud masking.
mergedS2Collection = ee.ImageCollection(mergedS2Collection)
  .map(S2_UTILITIES.mask_edges)
  .map(function(raster){
    return S2_UTILITIES.mask_clouds(raster, cloudProbability);
  });

// Generate a mosaic.
var s2Mosaic = mergedS2Collection
  .select(["B11", "B8", "B4", "B3", "B2"])
  .median()
  .clip(footprint);

// Engineer new bands.

// `MNDWI`
var mndwi = s2Mosaic
  .expression(S2_UTILITIES.bandCombinations.mndwi.expression)
  .rename(S2_UTILITIES.bandCombinations.mndwi.name);

var mndwiMask = mndwi.select(["MNDWI"]).gte(0.1).reproject(projection);

// Perform image segmentation (OTSU algorithm).

var otsuRectangle = ee.Geometry.Polygon(polyCoordinates);

vvkwargDefaults.otsuRegion = otsuRectangle;
vhkwargDefaults.otsuRegion = otsuRectangle;

var vvPreMask = S1_UTILITIES.edge_otsu_algorithm(preEventRaster.select("VV"), vvkwargDefaults);
var vvPostMask = S1_UTILITIES.edge_otsu_algorithm(postEventRaster.select("VV"), vvkwargDefaults);

var vhPreMask = S1_UTILITIES.edge_otsu_algorithm(preEventRaster.select("VH"), vhkwargDefaults);
var vhPostMask = S1_UTILITIES.edge_otsu_algorithm(postEventRaster.select("VH"), vhkwargDefaults);

// Create masks.
var preMask = vvPreMask.bitwiseAnd(vhPreMask).toInt8().clip(footprint).reproject(projection);
var postMask = vvPostMask.bitwiseAnd(vhPostMask).toInt8().clip(footprint).reproject(projection);

var permanentWaterSurfaces = preMask.bitwiseAnd(postMask).toInt8();

// Perform reprojections.
var reprojectedS2Mosaic = s2Mosaic.clip(footprint).reproject(projection);
var reprojectedMNDWI = mndwi.clip(footprint).reproject(projection);

preEventRaster = preEventRaster.clip(footprint).reproject(projection);
postEventRaster = postEventRaster.clip(footprint).reproject(projection);


/*
**************************************************************
  VISUALIZATION
**************************************************************
*/


// Generate categorical legends.

// `Dynamic-World` legend.
var dwLegendTitle = ui.Label({
  value: "DW",
  style: {
    margin: "0px",
    fontSize: "14px",
    fontWeight: "bold",
  }
});

var dwLegend = ui.Panel({
  style: {
    position: "bottom-left",
    padding: "5px"
  }
});

dwLegend.add(dwLegendTitle);

for (var key in dwLabelsPalette) {
  dwLegend.add(create_legend_row(dwLabelsPalette[key], key));
}

Map.centerObject(ring);
Map.add(dwLegend);

Map.addLayer(preEventRaster, s1Visualization, "rasters: S1-GRD (pre)");
Map.addLayer(postEventRaster, s1Visualization, "rasters: S1-GRD (post)");

Map.addLayer(reprojectedS2Mosaic, rgbVisualization, "rasters: S2-L2A (RGB)");
Map.addLayer(reprojectedMNDWI, mndwiVisualization, "rasters: S2-L2A (MNDWI)");
Map.addLayer(dwMosaic, dwVisualization, "rasters: DW");

Map.addLayer(mndwiMask, coverVisualization, "mndwi-mask");
Map.addLayer(preMask, coverVisualization, "rasters: S1-GRD (pre-mask)");
Map.addLayer(postMask, coverVisualization, "rasters: mask (post-mask)");
Map.addLayer(permanentWaterSurfaces, coverVisualization, "permanent waters");

Map.addLayer(regionVectors.filterBounds(footprint), {color: "white"}, "vectors: region");
Map.addLayer(ring, {color: "black"}, "vectors: ring");


/*
**************************************************************
  EXPORT
**************************************************************
*/


Export.table.toAsset({
  collection: drawnGeometries,
  description: ["water_surfaces_drawn_to_asset"].join("_"),
  assetId: destinationPath,
});
