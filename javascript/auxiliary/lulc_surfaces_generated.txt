/*
***************************************************************************
  IMPORTS
***************************************************************************
*/


var S1_UTILITIES = require("users/stamlazaros/hua:t-h-e-s-i-s/utilities/s1");


/*
*********************************************************************
  FUNCTIONS
*********************************************************************
*/


//-----------------------Data Displaying Functions-----------------------

function add_drawing_layer(geometries, name){
  /*
  Description:
    Adds a drawing layer to the map using specified geometries and a name.

  Parameters:
    geometries (string): The geometry of the featureCollection to add as a drawing layer.
    name  (string): The name for the drawing layer.

  Returns:
    -

  Execution:
    var polygons = ee.FeatureCollection("...")
    polygons.geometry().evaluate(function(geometries){
      add_drawing_layer(geometries, "kati");
    });
  */
  Map.drawingTools().addLayer([geometries], name);
}


/*
**********************************************************************
  PARAMETERS
**********************************************************************
*/


// `Dynamic World Land Cover`
var dwStartDate = "2018-01-01";
var dwEndDate = "2019-01-01";

// `Digital Elevation Model`
var demProvider = "USGS";

// `Sentinel-1 GRD`
var b1 = "VV";
var b2 = "VH";

var rasterIdentifiers = {
  pre_event: "S1A_IW_GRDH_1SDV_20141216T163133_20141216T163158_003747_00476D_87B6",
  post_event: "S1A_IW_GRDH_1SDV_20150202T163132_20150202T163157_004447_005723_9D4B"
};

// OTSU algorithm
var vvkwargDefaults = {
  "initialThreshold":-15,
  "reductionScale": 180,
  "smoothing": 100,
  "bandName": "VV",
  "connectedPixels": 100,
  "edgeLength": 35,
  "smoothEdges": 20,
  "cannyThreshold": 0.5,
  "cannySigma": 1,
  "cannyLt": 0.8,
  "maxBuckets": 256,
  "minBucketWidth": 0.001,
  "maxRaw": 1e6
};

var vhkwargDefaults = {
  "initialThreshold":-15,
  "reductionScale": 180,
  "smoothing": 100,
  "bandName": "VH",
  "connectedPixels": 100,
  "edgeLength": 35,
  "smoothEdges": 20,
  "cannyThreshold": 0.5,
  "cannySigma": 1,
  "cannyLt": 0.8,
  "maxBuckets": 256,
  "minBucketWidth": 0.001,
  "maxRaw": 1e6
};

var polyCoordinates = [
  20.521707734105185, 38.4405775054311,
  21.136942109105185, 38.91230332427433
];

// Projection of interest.
var projectionCRS = "EPSG:4326";
var projectionScale = 10;

// GEE assets.
var destinationPath = "users/stamlazaros/hua/t-h-e-s-i-s/assets/filters/emsr117/flood_surfaces";


/*
********************************************************************
  CONFIGURATION
********************************************************************
*/


// `Digital Elevation Models`
var demConfigs = {
  CGIAR: {    // `SRTM Digital Elevation Data Version 4`
    name: "CGIAR/SRTM90_V4"
  },
  NASA: {     // `NASA NASADEM Digital Elevation`
    name: "NASA/NASADEM_HGT/001"
  },
  USGS: {     // `NASA SRTM Digital Elevation`
    name: "USGS/SRTMGL1_003"
  },
  ASTER: {    // `AG100: ASTER Global Emissivity Dataset 100-meter V003`
    name: "NASA/ASTER_GED/AG100_003"
  }
};

// `Sentinel-1 GRD`
var s1Config = {
  name: "COPERNICUS/S1_GRD"
};

var s1Visualization = {
  min: [-25, -25, 0],
  max: [0, 0, 2],
  bands: ["VV", "VH", "VVVHQ"]
};

// OTSU algorithm
var otsuVisualization = {
  min: 0,
  max: 1,
  palette: ["deb887", "45b6fe"]
};

// Retrieve GEE assets.
var demConfig = demConfigs[demProvider];
var regionVectors = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");


/*
****************************************************************
  COMPUTATIONS
****************************************************************
*/


// Define the projection of interest.

var projection = ee.Projection(projectionCRS).atScale(projectionScale);

// Load, filter and process the raster collections.

// `Digital Elevation`
var elevation = ee.Image(demConfig.name).unmask();

// `Sentinel-1 GRD`
var preEventRaster = ee.Image([s1Config.name, rasterIdentifiers.pre_event].join("/"));
var postEventRaster = ee.Image([s1Config.name, rasterIdentifiers.post_event].join("/"));

// Handle geometries.
var preEventFootprint = preEventRaster.geometry();
var postEventFootprint = postEventRaster.geometry();

var intersectedFootprint = preEventFootprint.intersection(postEventFootprint, 1);
var ring = ee.Geometry.LinearRing(intersectedFootprint.coordinates().flatten());

regionVectors = regionVectors.filterBounds(intersectedFootprint);

// Apply angular-based radiometric slope correction.
var preEventRaster = S1_UTILITIES.slope_correction(preEventRaster, elevation);
var postEventRaster = S1_UTILITIES.slope_correction(postEventRaster, elevation);

// Apply a Refined-Lee speckle filter to reduce noise.
preEventRaster = S1_UTILITIES.refined_lee(preEventRaster);
postEventRaster = S1_UTILITIES.refined_lee(postEventRaster);

preEventRaster = ee.Image(preEventRaster);
postEventRaster = ee.Image(postEventRaster);

// Engineer new bands.

var quotientName = S1_UTILITIES.bandCombinations.quotient.name;

// `PRE_VVVHQ`
var prevvprevhQuotient = ee.Image().expression({
    expression: S1_UTILITIES.bandCombinations.quotient.expression,
    map: {
      b1: preEventRaster.select(b1),
      b2: preEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// `POST_VVVHQ`
var postvvpostvhQuotient = ee.Image().expression({
    expression: S1_UTILITIES.bandCombinations.quotient.expression,
    map: {
      b1: postEventRaster.select(b1),
      b2: postEventRaster.select(b2)
    }
  }).rename(quotientName.replace("b1", b1).replace("b2", b2));

// Incorporate extra bands into both pre- & post- event rasters.
preEventRaster = preEventRaster.addBands([prevvprevhQuotient]);
postEventRaster = postEventRaster.addBands([postvvpostvhQuotient]);

// Perform image segmentation.

var otsuRectangle = ee.Geometry.Polygon(polyCoordinates);

vvkwargDefaults.otsuRegion = otsuRectangle;
vhkwargDefaults.otsuRegion = otsuRectangle;

// `VV`
var vvPreMask = S1_UTILITIES.edge_otsu_algorithm(preEventRaster.select("VV"), vvkwargDefaults);
var vvPostMask = S1_UTILITIES.edge_otsu_algorithm(postEventRaster.select("VV"), vvkwargDefaults);

// `VH`
var vhPreMask = S1_UTILITIES.edge_otsu_algorithm(preEventRaster.select("VH"), vhkwargDefaults);
var vhPostMask = S1_UTILITIES.edge_otsu_algorithm(postEventRaster.select("VH"), vhkwargDefaults);

// Create masks.
var preMask = vvPreMask.bitwiseAnd(vhPreMask).toInt8().clip(intersectedFootprint).reproject(projection);
var postMask = vvPostMask.bitwiseAnd(vhPostMask).toInt8().clip(intersectedFootprint).reproject(projection);

var permanentWaterSurfaces = preMask.bitwiseAnd(postMask).toInt8();

// Perform reprojections.
preEventRaster = preEventRaster.clip(intersectedFootprint).reproject(projection);
postEventRaster = postEventRaster.clip(intersectedFootprint).reproject(projection);

// Generate vectors.
var vectors = postMask.addBands(postMask).selfMask().reduceToVectors({
  geometry: borders,
  crs: "EPSG:4326",
  scale: 50,
  geometryType: 'polygon',
  eightConnected: false,
  labelProperty: 'cover',
  reducer: ee.Reducer.lastNonNull(),
  maxPixels: 1e13
  
}).filterBounds(points);

vectors = vectors.map(function(vector){
  return vector.buffer(50).simplify(35);
});


/*
**************************************************************
  VISUALIZATION
**************************************************************
*/


Map.centerObject(ring);

Map.addLayer(preEventRaster, s1Visualization, "rasters: S1-GRD (pre-REPRO)");
Map.addLayer(postEventRaster, s1Visualization, "rasters: S1-GRD (post-REPRO)");

Map.addLayer(preMask, otsuVisualization, "rasters: mask (pre)");
Map.addLayer(postMask, otsuVisualization, "rasters: mask (post)");
Map.addLayer(permanentWaterSurfaces, otsuVisualization, "permanent waters");

Map.addLayer(vectors, {}, "vectors");


/*
**************************************************************
  EXPORT
**************************************************************
*/


Export.table.toAsset({
  collection: vectors,
  assetId: destinationPath,
  description: "drawn_vectors",
});
